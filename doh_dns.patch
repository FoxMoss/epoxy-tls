diff --git a/Cargo.toml b/Cargo.toml
index 08948b4..2cd00fb 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,10 +15,7 @@ Google and Clouflare based on `async/await`, `hyper`, and `tokio`.
 """
 
 [dependencies]
-hyper = "0.13.1"
-hyper-tls = "0.4.1"
-native-tls = "0.2"
-futures-util = "0.3.1"
+hyper = "1.1.0"
 serde_json = "1.0"
 serde_derive = "1.0"
 serde = "1.0"
@@ -27,7 +24,8 @@ num = "0.2.0"
 num-traits = "0.2"
 num-derive = "0.3.0"
 idna = "0.2.0"
-tokio = { version = "0.2.9", features = ["full"] }
-tower-service = "0.3.0"
 paste = "0.1.6"
 log = "0.4.8"
+wasmtimer = "0.2.0"
+http-body-util = "0.1.0"
+hyper-util-wasm = { version = "0.1.3", features = ["client", "client-legacy", "http1"] }
diff --git a/src/client.rs b/src/client.rs
index a385282..1d539d6 100644
--- a/src/client.rs
+++ b/src/client.rs
@@ -1,143 +1,11 @@
 //! HTTPS client to query DoH servers.
 use async_trait::async_trait;
-use futures_util::future::{err, ok, Ready};
-use hyper::{
-    client::{connect::dns::Name, HttpConnector},
-    error::Result as HyperResult,
-    Body, Client, Request, Response, Uri,
-};
-use hyper_tls::HttpsConnector;
-use std::{
-    io,
-    net::{IpAddr, Ipv4Addr},
-    sync::{
-        atomic::{AtomicBool, Ordering},
-        Arc,
-    },
-    task::{self, Poll},
-};
-use tower_service::Service;
+use hyper::{body::Incoming, Response, Uri};
+use hyper_util_wasm::client::legacy::Error;
 
 /// Creates a `GET` request over the given `URI` and returns its response. It is used to
 /// request data from DoH servers.
 #[async_trait]
-pub trait DnsClient: Default {
-    async fn get(&self, uri: Uri) -> HyperResult<Response<Body>>;
-}
-
-/// Hyper-based DNS client over SSL and with a static resolver to resolve DNS server names
-/// such as `dns.google` since Google does not accept request over `8.8.8.8` like Cloudflare
-/// does over `1.1.1.1`.
-pub struct HyperDnsClient {
-    client: Client<HttpsConnector<HttpConnector<UrlStaticResolver>>>,
-}
-
-impl Default for HyperDnsClient {
-    fn default() -> HyperDnsClient {
-        let mut http_connector = HttpConnector::new_with_resolver(UrlStaticResolver::new());
-        http_connector.enforce_http(false);
-        let mut connector = HttpsConnector::from((
-            http_connector,
-            native_tls::TlsConnector::new().unwrap().into(),
-        ));
-        connector.https_only(true);
-        HyperDnsClient {
-            client: Client::builder().keep_alive(true).build(connector),
-        }
-    }
-}
-
-#[async_trait]
-impl DnsClient for HyperDnsClient {
-    async fn get(&self, uri: Uri) -> HyperResult<Response<Body>> {
-        // The reason to build a request manually is to set the Accept header required by
-        // DNS servers.
-        let req = Request::builder()
-            .method("GET")
-            .uri(uri)
-            .header("Accept", "application/dns-json")
-            .body(Body::default())
-            .expect("request builder");
-        self.client.request(req).await
-    }
-}
-
-// This is resolver that statically resolves the Google DNS name to 8.8.8.8 and
-// 8.8.4.4 in a round robin fashion. The Cloudflare IPs are not resolved since those
-// are already statically defined in the request URL.
-#[derive(Clone)]
-struct UrlStaticResolver {
-    round_robin: Arc<AtomicBool>,
-}
-
-impl UrlStaticResolver {
-    fn new() -> UrlStaticResolver {
-        UrlStaticResolver {
-            round_robin: Arc::new(AtomicBool::new(true)),
-        }
-    }
-}
-
-impl Service<Name> for UrlStaticResolver {
-    type Response = UrlStaticAddrs;
-    type Error = io::Error;
-    type Future = Ready<Result<UrlStaticAddrs, io::Error>>;
-
-    fn poll_ready(&mut self, _cx: &mut task::Context<'_>) -> Poll<Result<(), io::Error>> {
-        Poll::Ready(Ok(()))
-    }
-
-    fn call(&mut self, name: Name) -> Self::Future {
-        if name.as_str() == "dns.google" {
-            let rr_ref = Arc::clone(&self.round_robin);
-            let rr = rr_ref.load(Ordering::Relaxed);
-            let addr = if rr {
-                rr_ref.store(false, Ordering::Relaxed);
-                IpAddr::V4(Ipv4Addr::new(8, 8, 8, 8))
-            } else {
-                rr_ref.store(true, Ordering::Relaxed);
-                IpAddr::V4(Ipv4Addr::new(8, 8, 4, 4))
-            };
-            ok(UrlStaticAddrs { inner: Some(addr) })
-        } else {
-            // This should never occur.
-            err(io::Error::from(io::ErrorKind::AddrNotAvailable))
-        }
-    }
-}
-
-// This only contains one IP address so the iterator only needs to go through it once.
-struct UrlStaticAddrs {
-    inner: Option<IpAddr>,
-}
-
-impl Iterator for UrlStaticAddrs {
-    type Item = IpAddr;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        if let Some(ip) = self.inner {
-            self.inner = None;
-            Some(ip)
-        } else {
-            None
-        }
-    }
-}
-
-#[cfg(test)]
-pub mod tests {
-    use super::*;
-    use std::str::FromStr;
-
-    #[tokio::test]
-    async fn test_static_resolve() {
-        let mut resolver = UrlStaticResolver::new();
-        let n = Name::from_str("dns.google").unwrap();
-        let mut g1 = resolver.call(n.clone()).await.unwrap();
-        assert_eq!(g1.next(), Some(IpAddr::V4(Ipv4Addr::new(8, 8, 8, 8))));
-        assert_eq!(g1.next(), None);
-        let mut g2 = resolver.call(n.clone()).await.unwrap();
-        assert_eq!(g2.next(), Some(IpAddr::V4(Ipv4Addr::new(8, 8, 4, 4))));
-        assert_eq!(g2.next(), None);
-    }
+pub trait DnsClient {
+    async fn get(&self, uri: Uri) -> Result<Response<Incoming>, Error>;
 }
diff --git a/src/dns.rs b/src/dns.rs
index e9e0234..82ca292 100644
--- a/src/dns.rs
+++ b/src/dns.rs
@@ -1,36 +1,23 @@
-use crate::client::{DnsClient, HyperDnsClient};
+use crate::client::DnsClient;
 use crate::error::{DnsError, QueryError};
 use crate::status::RCode;
 use crate::{Dns, DnsAnswer, DnsHttpsServer, DnsResponse};
 use hyper::Uri;
-use idna;
 use log::error;
-use std::time::Duration;
-use tokio::time::timeout;
-
-impl Default for Dns<HyperDnsClient> {
-    fn default() -> Dns<HyperDnsClient> {
-        Dns {
-            client: HyperDnsClient::default(),
-            servers: vec![
-                DnsHttpsServer::Google(Duration::from_secs(3)),
-                DnsHttpsServer::Cloudflare1_1_1_1(Duration::from_secs(10)),
-            ],
-        }
-    }
-}
+use wasmtimer::tokio::timeout;
+use http_body_util::BodyExt;
 
 impl<C: DnsClient> Dns<C> {
     /// Creates an instance with the given servers along with their respective timeouts
     /// (in seconds). These servers are tried in the given order. If a request fails on
     /// the first one, each subsequent server is tried. Only on certain failures a new
     /// request is retried such as a connection failure or certain server return codes.
-    pub fn with_servers(servers: &[DnsHttpsServer]) -> Result<Dns<C>, DnsError> {
+    pub fn with_servers(servers: &[DnsHttpsServer], client: C) -> Result<Dns<C>, DnsError> {
         if servers.is_empty() {
             return Err(DnsError::NoServers);
         }
         Ok(Dns {
-            client: C::default(),
+            client,
             servers: servers.to_vec(),
         })
     }
@@ -44,7 +31,7 @@ impl<C: DnsClient> Dns<C> {
                 Some(RCode::NoError) => {
                     let mut mxs = res
                         .Answer
-                        .unwrap_or_else(|| vec![])
+                        .unwrap_or_else(Vec::new)
                         .iter()
                         .filter_map(|a| {
                             // Get only MX records.
@@ -88,7 +75,7 @@ impl<C: DnsClient> Dns<C> {
             Ok(res) => match num::FromPrimitive::from_u32(res.Status) {
                 Some(RCode::NoError) => Ok(res
                     .Answer
-                    .unwrap_or_else(|| vec![])
+                    .unwrap_or_else(Vec::new)
                     .into_iter()
                     // Get only the record types requested. There is only exception and that is
                     // the ANY record which has a value of 0.
@@ -120,9 +107,9 @@ impl<C: DnsClient> Dns<C> {
                 Ok(Err(e)) => QueryError::Connection(e.to_string()),
                 Ok(Ok(res)) => {
                     match res.status().as_u16() {
-                        200 => match hyper::body::to_bytes(res).await {
+                        200 => match res.into_body().collect().await {
                             Err(e) => QueryError::ReadResponse(e.to_string()),
-                            Ok(body) => match serde_json::from_slice::<DnsResponse>(&body) {
+                            Ok(body) => match serde_json::from_slice::<DnsResponse>(&body.to_bytes()) {
                                 Err(e) => QueryError::ParseResponse(e.to_string()),
                                 Ok(res) => {
                                     return Ok(res);
@@ -260,399 +247,3 @@ rtypes! {
     /// Queries a well known service description record for the given name.
     (wks, 11);
 }
-
-#[cfg(test)]
-pub mod tests {
-    use async_trait::async_trait;
-    use hyper::StatusCode;
-    use hyper::{error::Result as HyperResult, Body, Response, Uri};
-    use std::sync::{
-        atomic::{AtomicUsize, Ordering},
-        Arc,
-    };
-    struct MockDnsClient {
-        response: Vec<(String, StatusCode)>,
-        counter: Arc<AtomicUsize>,
-    }
-
-    impl MockDnsClient {
-        fn new(response: &[(String, StatusCode)]) -> MockDnsClient {
-            MockDnsClient {
-                response: response.to_vec(),
-                counter: Arc::new(AtomicUsize::new(0)),
-            }
-        }
-    }
-
-    #[async_trait]
-    impl DnsClient for MockDnsClient {
-        async fn get(&self, _uri: Uri) -> HyperResult<Response<Body>> {
-            let counter = Arc::clone(&self.counter);
-            let index = counter.fetch_add(1, Ordering::SeqCst);
-            // If more calls than results are given, an out of bounds error should be obtained.
-            let chunks: Vec<Result<_, ::std::io::Error>> = vec![Ok(self.response[index].0.clone())];
-            let stream = futures_util::stream::iter(chunks);
-            let body = Body::wrap_stream(stream);
-            let mut response = Response::new(body);
-            *response.status_mut() = self.response[index].1;
-            Ok(response)
-        }
-    }
-
-    impl Default for MockDnsClient {
-        fn default() -> MockDnsClient {
-            MockDnsClient {
-                response: vec![],
-                counter: Arc::new(AtomicUsize::new(0)),
-            }
-        }
-    }
-
-    use super::*;
-
-    #[tokio::test]
-    async fn test_a() {
-        let response = String::from(
-            r#"
-        {
-  "Status": 0,
-  "TC": false,
-  "RD": true,
-  "RA": true,
-  "AD": false,
-  "CD": false,
-  "Question": [
-    {
-      "name": "www.sendgrid.com.",
-      "type": 1
-    }
-  ],
-  "Answer": [
-    {
-      "name": "www.sendgrid.com.",
-      "type": 5,
-      "TTL": 988,
-      "data": "sendgrid.com."
-    },
-    {
-      "name": "sendgrid.com.",
-      "type": 1,
-      "TTL": 89,
-      "data": "169.45.113.198"
-    },
-    {
-      "name": "sendgrid.com.",
-      "type": 1,
-      "TTL": 89,
-      "data": "167.89.118.63"
-    },
-    {
-      "name": "sendgrid.com.",
-      "type": 1,
-      "TTL": 89,
-      "data": "169.45.89.183"
-    },
-    {
-      "name": "sendgrid.com.",
-      "type": 1,
-      "TTL": 89,
-      "data": "167.89.118.65"
-    }
-  ],
-  "Comment": "Response from 2600:1801:13::1."
-    }"#,
-        );
-        let d = Dns {
-            client: MockDnsClient::new(&[(response, StatusCode::OK)]),
-            servers: vec![DnsHttpsServer::Google(Duration::from_secs(5))],
-        };
-        let r = d.resolve_a("sendgrid.com").await.unwrap();
-        assert_eq!(r.len(), 4);
-        assert_eq!(r[0].name, "sendgrid.com.");
-        assert_eq!(r[0].data, "169.45.113.198");
-        assert_eq!(r[0].r#type, 1);
-        assert_eq!(r[0].TTL, 89);
-        assert_eq!(r[1].name, "sendgrid.com.");
-        assert_eq!(r[1].data, "167.89.118.63");
-        assert_eq!(r[1].r#type, 1);
-        assert_eq!(r[1].TTL, 89);
-        assert_eq!(r[2].name, "sendgrid.com.");
-        assert_eq!(r[2].data, "169.45.89.183");
-        assert_eq!(r[2].r#type, 1);
-        assert_eq!(r[2].TTL, 89);
-        assert_eq!(r[3].name, "sendgrid.com.");
-        assert_eq!(r[3].data, "167.89.118.65");
-        assert_eq!(r[3].r#type, 1);
-        assert_eq!(r[3].TTL, 89);
-    }
-
-    #[tokio::test]
-    async fn test_mx() {
-        let response = String::from(
-            r#"
-        {
-  "Status": 0,
-  "TC": false,
-  "RD": true,
-  "RA": true,
-  "AD": false,
-  "CD": false,
-  "Question": [
-    {
-      "name": "gmail.com.",
-      "type": 15
-    }
-  ],
-  "Answer": [
-    {
-      "name": "gmail.com.",
-      "type": 15,
-      "TTL": 3599,
-      "data": "30 alt3.gmail-smtp-in.l.google.com."
-    },
-    {
-      "name": "gmail.com.",
-      "type": 15,
-      "TTL": 3599,
-      "data": "5 gmail-smtp-in.l.google.com."
-    },
-    {
-      "name": "gmail.com.",
-      "type": 15,
-      "TTL": 3599,
-      "data": "40 alt4.gmail-smtp-in.l.google.com."
-    },
-    {
-      "name": "gmail.com.",
-      "type": 15,
-      "TTL": 3599,
-      "data": "10 alt1.gmail-smtp-in.l.google.com."
-    },
-    {
-      "name": "gmail.com.",
-      "type": 15,
-      "TTL": 3599,
-      "data": "20 alt2.gmail-smtp-in.l.google.com."
-    }
-  ],
-  "Comment": "Response from 2001:4860:4802:32::a."
-}"#,
-        );
-        let d = Dns {
-            client: MockDnsClient::new(&[(response.clone(), StatusCode::OK)]),
-            servers: vec![DnsHttpsServer::Google(Duration::from_secs(5))],
-        };
-        let r = d.resolve_mx_and_sort("gmail.com").await.unwrap();
-        assert_eq!(r.len(), 5);
-        assert_eq!(r[0].name, "gmail.com.");
-        assert_eq!(r[0].data, "gmail-smtp-in.l.google.com.");
-        assert_eq!(r[0].r#type, 15);
-        assert_eq!(r[0].TTL, 3599);
-        assert_eq!(r[1].name, "gmail.com.");
-        assert_eq!(r[1].data, "alt1.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[1].r#type, 15);
-        assert_eq!(r[1].TTL, 3599);
-        assert_eq!(r[2].name, "gmail.com.");
-        assert_eq!(r[2].data, "alt2.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[2].r#type, 15);
-        assert_eq!(r[2].TTL, 3599);
-        assert_eq!(r[3].name, "gmail.com.");
-        assert_eq!(r[3].data, "alt3.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[3].r#type, 15);
-        assert_eq!(r[3].TTL, 3599);
-        assert_eq!(r[4].name, "gmail.com.");
-        assert_eq!(r[4].data, "alt4.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[4].r#type, 15);
-        assert_eq!(r[4].TTL, 3599);
-
-        let d = Dns {
-            client: MockDnsClient::new(&[(response, StatusCode::OK)]),
-            servers: vec![DnsHttpsServer::Google(Duration::from_secs(5))],
-        };
-        let r = d.resolve_mx("gmail.com").await.unwrap();
-        assert_eq!(r.len(), 5);
-        assert_eq!(r[0].name, "gmail.com.");
-        assert_eq!(r[0].data, "30 alt3.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[0].r#type, 15);
-        assert_eq!(r[0].TTL, 3599);
-        assert_eq!(r[1].name, "gmail.com.");
-        assert_eq!(r[1].data, "5 gmail-smtp-in.l.google.com.");
-        assert_eq!(r[1].r#type, 15);
-        assert_eq!(r[1].TTL, 3599);
-        assert_eq!(r[2].name, "gmail.com.");
-        assert_eq!(r[2].data, "40 alt4.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[2].r#type, 15);
-        assert_eq!(r[2].TTL, 3599);
-        assert_eq!(r[3].name, "gmail.com.");
-        assert_eq!(r[3].data, "10 alt1.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[3].r#type, 15);
-        assert_eq!(r[3].TTL, 3599);
-        assert_eq!(r[4].name, "gmail.com.");
-        assert_eq!(r[4].data, "20 alt2.gmail-smtp-in.l.google.com.");
-        assert_eq!(r[4].r#type, 15);
-        assert_eq!(r[4].TTL, 3599);
-    }
-
-    #[tokio::test]
-    async fn test_txt() {
-        let response = String::from(
-            r#"
-        {
-  "Status": 0,
-  "TC": false,
-  "RD": true,
-  "RA": true,
-  "AD": false,
-  "CD": false,
-  "Question": [
-    {
-      "name": "google.com.",
-      "type": 16
-    }
-  ],
-  "Answer": [
-    {
-      "name": "google.com.",
-      "type": 16,
-      "TTL": 3599,
-      "data": "\"facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95\""
-    },
-    {
-      "name": "google.com.",
-      "type": 16,
-      "TTL": 3599,
-      "data": "\"globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=\""
-    },
-    {
-      "name": "google.com.",
-      "type": 16,
-      "TTL": 299,
-      "data": "\"docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e\""
-    },
-    {
-      "name": "google.com.",
-      "type": 16,
-      "TTL": 299,
-      "data": "\"docusign=1b0a6754-49b1-4db5-8540-d2c12664b289\""
-    },
-    {
-      "name": "google.com.",
-      "type": 16,
-      "TTL": 3599,
-      "data": "\"v=spf1 include:_spf.google.com ~all\""
-    }
-  ],
-  "Comment": "Response from 216.239.36.10."
-}"#,
-        );
-        let d = Dns {
-            client: MockDnsClient::new(&[(response, StatusCode::OK)]),
-            servers: vec![DnsHttpsServer::Google(Duration::from_secs(5))],
-        };
-        let r = d.resolve_txt("google.com").await.unwrap();
-        assert_eq!(r.len(), 5);
-        assert_eq!(r[0].name, "google.com.");
-        assert_eq!(
-            r[0].data,
-            "\"facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95\""
-        );
-        assert_eq!(r[0].r#type, 16);
-        assert_eq!(r[0].TTL, 3599);
-        assert_eq!(r[1].name, "google.com.");
-        assert_eq!(
-            r[1].data,
-            "\"globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=\""
-        );
-        assert_eq!(r[1].r#type, 16);
-        assert_eq!(r[1].TTL, 3599);
-        assert_eq!(r[2].name, "google.com.");
-        assert_eq!(
-            r[2].data,
-            "\"docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e\""
-        );
-        assert_eq!(r[2].r#type, 16);
-        assert_eq!(r[2].TTL, 299);
-        assert_eq!(r[3].name, "google.com.");
-        assert_eq!(
-            r[3].data,
-            "\"docusign=1b0a6754-49b1-4db5-8540-d2c12664b289\""
-        );
-        assert_eq!(r[3].r#type, 16);
-        assert_eq!(r[3].TTL, 299);
-        assert_eq!(r[4].name, "google.com.");
-        assert_eq!(r[4].data, "\"v=spf1 include:_spf.google.com ~all\"");
-        assert_eq!(r[4].r#type, 16);
-        assert_eq!(r[4].TTL, 3599);
-    }
-
-    #[tokio::test]
-    async fn test_retries() {
-        let response = String::from(
-            r#"
-{
-  "Status": 0,
-  "TC": false,
-  "RD": true,
-  "RA": true,
-  "AD": false,
-  "CD": false,
-  "Question": [
-    {
-      "name": "www.google.com.",
-      "type": 1
-    }
-  ],
-  "Answer": [
-    {
-      "name": "www.google.com.",
-      "type": 1,
-      "TTL": 163,
-      "data": "172.217.11.164"
-    }
-  ]
-}"#,
-        );
-        // Retry if more than server is given.
-        let d = Dns {
-            client: MockDnsClient::new(&[
-                ("".to_owned(), StatusCode::INTERNAL_SERVER_ERROR),
-                (response.clone(), StatusCode::OK),
-            ]),
-            servers: vec![
-                DnsHttpsServer::Google(Duration::from_secs(5)),
-                DnsHttpsServer::Cloudflare1_1_1_1(Duration::from_secs(5)),
-            ],
-        };
-        let r = d.resolve_a("www.google.com").await.unwrap();
-        assert_eq!(r.len(), 1);
-        assert_eq!(r[0].name, "www.google.com.");
-        assert_eq!(r[0].data, "172.217.11.164");
-        assert_eq!(r[0].r#type, 1);
-        assert_eq!(r[0].TTL, 163);
-
-        // Not all errors should be retried.
-        let d = Dns {
-            client: MockDnsClient::new(&[
-                ("".to_owned(), StatusCode::BAD_REQUEST),
-                (response.clone(), StatusCode::OK),
-            ]),
-            servers: vec![
-                DnsHttpsServer::Google(Duration::from_secs(5)),
-                DnsHttpsServer::Cloudflare1_1_1_1(Duration::from_secs(5)),
-            ],
-        };
-        let r = d.resolve_a("www.google.com").await;
-        assert!(r.is_err());
-
-        // If only one server is given, an error should be received.
-        let d = Dns {
-            client: MockDnsClient::new(&[
-                ("".to_owned(), StatusCode::INTERNAL_SERVER_ERROR),
-                (response.clone(), StatusCode::OK),
-            ]),
-            servers: vec![DnsHttpsServer::Google(Duration::from_secs(5))],
-        };
-        let r = d.resolve_a("www.google.com").await;
-        assert!(r.is_err());
-    }
-}
diff --git a/src/lib.rs b/src/lib.rs
index 177ccd4..7afa4b3 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -96,34 +96,23 @@ struct DnsResponse {
 /// These servers are given to [Dns::with_servers] in order of priority. Only subsequent
 /// servers are used if the request needs to be retried.
 #[derive(Clone)]
-pub enum DnsHttpsServer {
-    /// Googe's DoH server. Unfortunately, Google doesn't allow to query `8.8.8.8` or
-    /// `8.8.4.4` directly. It needs the hostname `dns.google`. If this option is
-    /// given, `8.8.8.8` and `8.8.4.4` will be used in round robin form for each new
-    /// connection.
-    Google(Duration),
-    /// Cloudflare's `1.1.1.1` DOH server. Cloudflare does not respond to `ANY` Dns
-    /// requests so [Dns::resolve_any] will always return an error.
-    Cloudflare1_1_1_1(Duration),
-    /// Cloudflare's `1.0.0.1` DOH server. Cloudflare does not respond to `ANY` Dns
-    /// requests so [Dns::resolve_any] will always return an error.
-    Cloudflare1_0_0_1(Duration),
+pub struct DnsHttpsServer {
+    uri: String,
+    timeout: Duration,
 }
 
 impl DnsHttpsServer {
-    fn uri(&self) -> &str {
-        match self {
-            Self::Google(_) => "https://dns.google/resolve",
-            Self::Cloudflare1_1_1_1(_) => "https://1.1.1.1/dns-query",
-            Self::Cloudflare1_0_0_1(_) => "https://1.0.0.1/dns-query",
+    pub fn new(uri: String, timeout: Duration) -> Self {
+        Self {
+            uri,
+            timeout,
         }
     }
+    fn uri(&self) -> &str {
+        &self.uri
+    }
     fn timeout(&self) -> Duration {
-        match self {
-            Self::Google(t) => *t,
-            Self::Cloudflare1_1_1_1(t) => *t,
-            Self::Cloudflare1_0_0_1(t) => *t,
-        }
+        self.timeout
     }
 }
 
